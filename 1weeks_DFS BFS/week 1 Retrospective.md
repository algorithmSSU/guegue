# 1주차

# 시간 복잡도

---

- 일반적으로 수행시간은 **1억 번의 연산을 1초의 시간으로 간주**하여 예측

- ex) 시간 제한 2초 → 2억 번 이하의 연산 횟수

- 연산 횟수  = 시간복잡도 * 데이터 크기

- 시간복잡도 도출 기준 2가지
1. 상수 → 시간 복잡도 계산에서 제외
2. 가장 많이 중첩된 반복문의 수행 횟수가 기준

# 디버깅

---

- 디버깅 → 논리 오류를 찾아 바로잡는 과정

# DFS

---

- 그래프 완전 탐색 기법 중 하나
- 재귀 사용 → stack overflow 유의

<aside>
💡 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법

</aside>

- 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.
- 즉, 넓게(wide) 탐색하기 전에 깊게(deep) 탐색하는 것이다.
- 사용하는 경우: 모든 노드를 방문 하고자 하는 경우에 이 방법을 선택한다.
- 깊이 우선 탐색(DFS)이 너비 우선 탐색(BFS)보다 좀 더 간단하다.
- 단순 검색 속도 자체는 너비 우선 탐색(BFS)에 비해서 느리다.

### DFS 특징

- 자기 자신을 호출하는 순환 알고리즘의 형태 를 가지고 있다.
- 이 알고리즘을 구현할 때 가장 큰 차이점은, 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사 해야 한다는 것이다.

![Untitled](https://user-images.githubusercontent.com/62997391/177922065-d7953c9b-dcd1-4e73-9d3f-f439033cd130.png)

### 핵심

- ArrayList 통한 인접리스트 만들어주기
- boolean[]을 통한 방문 배열 만들어주기 (뒤로 돌아가야 하는 경우에?)

# BFS

---

- Breadth-first-search, 너비우선탐색
- 시작노드에서 출발해서 시작 노드를 기준으로 가까운 노드들 먼저 방문하면서 탐색
- Queue 이용해서 구현
- 가까운 노드를 우선하여 탐색하므로 목표 노드에 도착하는 경로가 여러 개일때 최단 경로를 보장

### Key Point

1. 방문했던 노드는 다시 방문 X →  boolean[] visited
2. 그래프를 인접리스트로 표현
3. 여기까지 DFS와 동일하지만 Stack(재귀)이 아닌 Queue 사용
